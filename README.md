# Висновки
Розглянемо результати роботи алгоритмів та їх часову складність за допомогою таблиці:
| Алгоритм           | Тест 1               |  Тест 2              | Тест 3               | Тест 4              
:------------------- | :------------------- | :------------------- | :------------------- | :-------------------
| find_min_coins     | 0.00015258           | 0.04322967           | 0.14301125           | 68.17155450          
| find_coins_greedy  | 0.00000513           | 0.00000533           | 0.00000563           | 0.00000679   


* Тест 1 <br>
монети = [50, 25, 10, 5, 2, 1] <br>
сума = 113
* Тест 2 <br>
монети = [50, 25, 10, 5, 2, 1] <br>
сума = 23313
* Тест 3 <br>
монети = [10, 5, 2, 1] <br>
сума = 97933
* Тест 4 <br>
монети = [10, 5, 2, 1] <br>
сума = 45789537

**find_min_coins** має велику часову складність, стає непрактичним особливо при великих сумах. **find_coins_greedy** виявляється швидшим та менш витратним за рахунок своєї жадібної стратегії вибору монет в усіх тестових сценаріях.

У випадку **find_min_coins** здійснюється рекурсивне обчислення кількості монет для кожного можливого варіанту, що призводить до значного зростання кількості операцій при збільшенні суми. Часова складність цього алгоритму може бути виражена у вигляді O(2^n), де n - розмір вхідних даних.

**find_coins_greedy** використовує жадібний підхід та обчислює кількість монет на основі доступних найбільших номіналів. Оскільки алгоритм ітерується лише по одному разу по відсортованому списку монет, його часова складність зазвичай визначається як O(n), де n - розмір вхідних даних.